\chapter{Introduction}

\section{Background and Motivation}
Code Completion is an established feature of certain programming environments. Being able to quickly find the most likely next :term speeds up the progress of writing a script as well as guides amateur programmers in learning to utilize libraries sensibly. 

There are two approaches to code completion. \textit{Static code completion} forms a list of relevant predictions based on static code analysis and usually sorts the suggestions alphabetically. Its counterpart, \textit{intelligent code completion} sorts the predictions based on relevancy. This is done using machine learning, more specifically transformer models which are trained on code samples to learn what is most likely to complete the statement. Intelligent code completion speeds up the coding experience for the user as they are more likely to find the appropriate next step at the top of the list.

There are a multiple pre-trained transformer models like the \textit{bidirectional encode representations from transformer} (BERT) and the \textit{generative pre-trained transformer} (GPT) designed for solving natural language problems.

Code completion is such a problem, however brings its own set of difficulties concerning syntax and structure of the code. Code is much more definitive than plain text. If it was treated the same as plain text, it would most likely cause a compiling error. When comparing a code snippet to a verbal description of that same script, the code snippet would have to stay the same to keep its meaning while the verbal description could look many different ways while still containing the same information.
 
Previous works by the Meta research group have tackled this issue by feeding \textit{abstract syntax trees} (AST) to the transformer instead of only plain text. AST are a form of code representation that contain the structure of the code as well as the code itself. This makes it possible to make reasonable predictions and generate code that will compile. 
 
Yet there are other ways to represent code than AST. For instance, a \textit{control flow graph} (CFG) provides information about the sequence of statements in a code snippet. The edges of the graph show in what order the code is traversed. This gives additional information about structures such as conditionals and loops. 

For example a regular language model would have to interpret a while-loop as something that is to be repeated and understand what a condition is. While it is possible to train a language model to do those things, adding information about the control flow will reduce training time and the amount of training data needed. The aim is also to ensure the model works properly.

(example graph)

This research thesis will evaluate how well a CFG performs in code completion compared to AST. To take on this task, the same transformer model will be adapted to take CFG as the input instead of AST.
